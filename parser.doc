    3.0  __The Parser__

    The parser uses a grammar and a lexicon to parse input
sentences and generate tree structures with grammatical and
semantic information.  There are four things to understand
in the operation of the parser.  They are

    1.  the representation of the lexicon,
    2.  the representation of the grammar,
    3.  the structure of the parse tree generated by 
        the parser, and
    4.  the algorithm for building parse trees from 
        input sentences.

    I will describe these four points in order, but first
will give a brief overview.  At the end of this section are
a description of how infinite left recursion is handled, and
some explanation for the sample parse trace diagram which is
included at the end.

    The grammar is a context-free grammar with associated
semantic composition rules.  The parse algorithm begins with
a start symbol, such as "s" and searches all possible
expansions.  It recursively builds trees containing both the
information from the context-free rules and the translation
rules.  At the leaves of the parse tree the semantic values
of the lexical items take the place of translation rules.
It generates all possible parses, thus handling ambiguities.
The plausible trees are limited by the number of words in
the input sentence.

    3.1  __The Representation of the Lexicon__

    The lexicon simply contains lexical items associated
with categories and with semantic values.  For example,

    p1.a.   name:  mary m
       b.   n:     duck n-duck'
       c.   v1:    duck v-duck'
    
 defines three lexical items.  The first is the name "Mary"
which corresponds to the item "m" in the model.  The second
and third define two categories and semantic values for the
word "duck".  The first of these defines a lexical item of
the "n" (noun) category with a semantic value "n-duck'".
The second of these defines something of the "v1"
(intransitive verb) category with a semantic value of
"v-duck'".

    Lexical items are kept in "word" structures.  This
structure is declared in Idol as

    p2.a.   class word( public category, 
                        public w, 
                        public trans )
    
 The category is kept in the "category" field, the word form
in the "w" field, and the semantic value in the "trans"
field.  For instance, the name definition above would have a
structure like

    p3.a.   word( "name", "mary", "m" )

 "name" being the category, "mary" the form of the word, and
"m" the semantic value.

    A lexicon contains two tables.  These each contain links
to lists of lexical items stored in "word" structures.  One
of the tables is referenced by word forms, the other by
category.  With the lexical definitions shown here, getting
the list of words with the form "duck" by

    p4.a.   word_t["duck"]

will produce the list

    p5.a.   [word("n","duck","n-duck'"), 
             word("v1","duck","v-duck'")
            ]
    
 This list contains two word structures, each with the word
form "duck".

    3.2  __The Representation of the Grammar__

    The grammar contains context free rules with associated
semantic composition rules.  For example,

    p6.a.  s     -> np vp      => (2 1)
       b.  np    -> det n-bar  => ! 1 (gamma x 
                                    (1 &var (2 &var) x))
       c.  n-bar -> n          => (gamma x (1 x))
       d.  vp    -> v1         => (gamma x (1 x))
       e.  vp    -> v2 np      => (gamma x (1 x 2))

    Each of the grammar rules has three major parts: the
left-hand side, the right-hand side, and the semantic
composition rule.  The left-hand side and the right-hand
side are separated by a "->".  The semantic composition rule
follows a "=>".  All three parts must be present for the
rule to be accepted by the program.  The left-hand side and
the right-hand side are relevant for the parser.  The
translation rules will be discussed in the section on the
translator.

    A grammar is a table keyed by the left-hand side of
these rules to produce lists of "rule" structures.  A "rule"
structure contains the right-hand side and translation rule
parts of the grammatical rule.  This structure is declared
in Idol as (p7.a).

    p7.a.   class rule( public exp, public tran )

    The "exp" part is the expansion of the left-hand side,
i.e. the right-hand side.  The "tran" part is the
translation rule.

    There are lists associated with each symbol because
there may be multiple rules with the same left-hand side.
For example, in the example grammar (p6) there are two "vp"
rules (p6.d-e).

    The two parts of the "rule" structure are stored as
lists of strings, each string being a word or punctuation
mark.  Referencing the grammar with "vp" will produce

    p8.a.   [rule(["v1"],      
                  ["(","gamma","x",
                   "(","1","x",")",")"]),
             rule(["v2","np"], 
                  ["(","gamma","x",
                   "(","1","x","2",")",")"])
            ]
    
 This list has representations of the two "vp" rules
in (p.6.d-e).

    3.3 __Parse Tree Structure__

    Parse trees are produced by the parser.  These are trees
which contain node names, or categories from the grammatical
rules used to generate the trees and the translation rules
associated with the context-free rules.  At each node in the
tree are three parts:

    1.  a semantic translation rule,
    2.  a node category from a grammar rule, and
    3.  a list of child parse trees.
    
    Here is a graphical example of a parse tree for the
sentence "Mary kissed George".

    p9.a.   Mary kissed George
                   s        
                (2 1)       
             ______|______  
             |           |
             np          vp
             1  (gamma x(1 x 2))
             |        ___|____
            name      |      |
             m        v2     np
             |       kiss'   1
            mary      |      |
                    kissed  name
                             g
                             |
                           george

    Consider the top "s" node.  It has a category ("s"), a
semantic composition rule ("(2 1)"), and two daughter nodes.
The daughters are in a list.

    The parse trees are built from a 'p_tree' structure.
This structure is defined, in Idol, as (p10.a)

    p10.a.  class p_tree( public trans, 
                          public cat, 
                          public children )
    
    The "trans" part contains the semantic composition rule
for the current node.  The "cat" part holds the category of
the node.  The "children" part is a list of "p_trees", or
strings in the case of lexical leaves.

    3.4  __The Parsing Algorithm__

    The parser is a recursive descent parser.  It begins
with a start symbol and builds trees from the top down
trying to match the lexical categories with words in the
input sentence.  The recursion is limited by how many items
are in the input sentence.  The parsing is done strictly
from left to right; no right branches are attempted until
all branches leftwards have resulted in lexical matches.

    Parsing a sentence takes place in the context of three
things: a sentence, a goal symbol, and the current grammar.
The parser generates all possible p_trees for the given
sentence.  The goal symbol is the name of the node which
should be at the top of the parse tree.  This is passed as a
parameter to the interface procedure.  The current grammar
is kept by the global variable "cur_g".

    There are three levels to the parse algorithm.  The
highest is the interface routine 'parse'.  The middle
routine is the recursive descent parser, 'rd_parse'.  The
lowest is the lexical matcher, 'parse_match'.

    There are two global variables associated with the
parsing algorithm.  One is 'p_subject', and the other is
'p_pos'.  Only 'parse' and 'parse_match' interact with these
variables.  'rd_parse' does not directly deal with them.

    The interface routine, 'parse', initializes these
variables before invoking 'rd_parse'.  'p_pos' holds the
current position in the sentence throughout the parsing.  It
is initialized to 1 (the first word) by 'parse'.

    The input sentence is made into a list of words and
punctuation marks from the input string and the list is
stored in 'p_subject'.  For example,

    p11.a.  "mary, george kissed."  

becomes  

    p11.b.  ["mary", ",", "george", "kissed", "."]

    The value of 'p_pos' indicates which item in the list is
the current word.

    All items in the list must be matched by an item in the
lexicon, or by something in a grammar rule.  And conversely,
every branch in the tree must end in a leaf with an item
from the input sentence.  The parser cannot match null
items.

    Once 'parse' has done its two assignments, its main duty
is done.  It passes the 'goal' symbol and the number of
items to be matched (the length of 'p_subject') to
'rd_parse'.  'parse' generates as its results everything
that 'rd_parse' generates.

    The general process of the recursion of 'rd_parse' is
that expansions are made and left branches tried until a
lexical match is made.  Then the recursions suspend,
generating subtrees from the bottom up.  A branch is
expanded after all branches to its left have been completely
explored and have made lexical matches.  The rightmost
suspended procedure is the one that resumes at any time and
the process backtracks leftward until a new expansion can be
tried going right.  This is to say that after a tree has
been generated, the rightmost branches are trimmed off until
there is a new way to build a tree.

    'rd_parse' can be given a 'goal' parameter of two types:
a list, or a string.  'rd_parse' with a string type 'goal'
will produce only p_tree structures, and with a list type
'goal' will produce only lists of p_tree structures.

    With a list type 'goal' 'rd_parse' takes the left-most
element and calls itself with that string as a 'goal'.
(This will lead to a lexical match.)  After successfully
getting a p_tree on the left it recurses on the right with
the rest of the list.  If that recursion succeeds 'rd_parse'
puts the p_tree made from the left-most element of 'goal' at
the front of the list returned by the right recursion, then
it suspends, generating the list that it constructed.  When
the procedure resumes, it resumes the call that generated
the list of right subtrees.  When the call to the right
fails to generate any more, the left recursion is resumed,
and the process begins again.  When the left explorations
quit generating results, the procedure fails.

    With a string type 'goal' 'rd_parse' gets all the
expansions for it and recurses with every one of these lists
as 'goal's.  This drives the process just described above.
After it tries all the expansions, it attempts to make a
lexical match, by calling 'parse_match' with the 'goal'.
Since it makes both attempts, Myshkin is not restricted to
"Chomsky Normal Form" grammars.

    Consider the grammar rules (p12.a-b) and their
representation (p13.a).

    p12.a.  vp -> v2 np => (gamma x (1 x 2))
        b.  vp -> v3 np => (gamma x (1 x 2 ?))
    
    p13.a.  [ rule( ["v2","np"], ["(","gamm...)",")"] ),
              rule( ["v3","np"], ["(","gamm...)",")"] ) ]

    With the 'goal' "vp" 'rd_parse' will fetch the list
(p13.a) (assuming the grammar (p12)).  'rd_parse' will take
the expansion parts of the 'rule' structures, and will
recurse with these lists.  If those recursions generate
lists of subtrees then p_tree nodes will be built from the lists
and from the information in the 'rule' structures.  For
instance, if the list 'p-list' were generated from passing
one of the expansion lists from (p13.a) to 'rd_parse' then
the p_tree (p14.a) would be built and generated.

    p14.a.  p_tree( ["(","gamm...)",")"], "vp", p-list )

    The list of p_trees generated from the expansion becomes
the list of children of the node.  The translation rule
associated with the expansion is used as the translation
rule for the p_tree node.  The 'goal' symbol becomes the
node category label.

    After generating all the possible p_trees by this
method, 'rd_parse' calls 'parse_match' to try and make a
lexical match in the input sentence.  The 'goal' is passed
to 'parse_match' by 'rd_parse'.  The goal at this level is
assumed to be a lexical category.  

    'parse_match' is responsible for the position in the
sentence, which is kept in the global variable 'p_pos'.  It
gets the current word from 'p_subject' and then increments
'p_pos'.  For each of the lexical matches made the
procedure suspends, generating a p_tree made from the
lexical item matched.  When all lexical matches are complete
(this may occur at immediately, or after one or more
suspensions), 'p_pos' is decremented.

    We will consider a small example for 'parse_match'.
Suppose 'parse_match' is called with a 'goal' parameter of
"n", 'p_pos' is 2, and 'p_subject' is

    p15.a.   ["a", "duck", "died", "."]

 The current word is gotten from 'p_subject'.  It is item 2,
"duck", in accordance with 'p_pos'.  After this 'p_pos' is
incremented to 3.

    To check for lexical matches 'parse_match' fetches from
the current lexicon the list of 'word' structures with word
forms of "duck".  The list is (p16.a).
    
    p16.a.    [word("n","duck","n-duck'"), 
               word("v1","duck","v-duck'")]
    
    The next thing for 'parse_match' to do is check each
item in the list to see if the 'goal' matches the 'category'
of the word.  The first one does match.  The procedure
suspends with the p_tree (p17.a)

    p17.a.    p_tree("n-duck'","n",["duck"])

 as its value.  When the procedure resumes the second 'word'
is checked.  Since the category does not match, it is not
used.  Now that all items in the 'word' list have been
checked 'p_pos' is decremented back to 2 and the procedure
fails indicating that no more matches are available.

    The reason for incrementing and decrementing 'p_pos' in
this way is that while parse_match is suspended the parser
continues processing rightwards from the current word.  To
be in the situation presupposed for this small example,
'parse_match' will have been previously called and will have
matched "a" (the first item in 'p_subject').  While the
events in the example occur the call of 'parse_match' that
matched "a" will remain suspended.  After the completion of
the example (after 'parse_match("duck")' fails) that
previous call to 'parse_match' will resume to make a new
match or to decrement 'p_pos' back to 1.

    'parse_match' will grant matches between 'goal' and
items in the input sentence when there is no lexical entry
of that form.  This allows things to be matched from the
grammatical rule.  For instance, a period (".") may appear
in a grammatical rule and be matched in the sentence,
provided there are no words with the form "." in the
lexicon.  A match of this kind will generate a p_tree with
an empty translation, and the category and the leaf will be
the 'goal'.  For example, matching a goal of "." will
produce (p18.a).

    p18.a.    p_tree( "", ".", ["."] )

 This is essentially a meaningless node, but this action has
two implications.  By being matched by 'parse_match' it will
have the effect of incrementing the current position, so
that parsing can continue moving rightward.  Generating the
p_tree maintains the type of the 'parse_match' procedure.

    3.5  __Left Recursion__

    'rd_parse' tracks how many items may be matched by each
recursion.  This is done with the second parameter
'target_length'.  In a particular call of 'rd_parse' where
the goal is a list of n items, the recursion on the left can
match no more than 'target_length' minus one less than n,
and the call on the right may match no more than
'target_length' minus 1.  For instance, if the first call of
'rd_parse' is with a 'goal' of "s" and a 'target_length' of
5 (i.e. there are 5 items in 'p_subject'), and an expansion

    p19.a.    ["np", "vp", "."]

 of three items is to be tried, then the recursion for "np"
will have a 'target_length' of 3.  For instance if the "np"
branch were to match 4 items that would leave 1 item left
for "vp" and "." to match.  Since every branch must match at
least one lexical item for the "np" branch to match 4 would
lead to an incomplete parse.

    When a call to 'rd_parse' is made with a 'target_length'
of zero, it fails.  When 'target_length' gets to zero this
means that there are too few items in 'p_subject' to match
all the branches in the tree.

    3.6  __An Example Parse Trace__

    Included in this paper is an example parse trace.
Because of complexity a completely unrealistic grammar has
been used for the trace example.  This is shown in (p16).
The lexicon is (p17).  The example sentence and p_tree are
shown in (p18).

    p16.a.    s -> name verb .       => (2 1)
        b.    s -> name verb name .  => (2 1 3)
    
    p17.a.    name: george g; mary m
        b.    verb: kissed kiss'; sighed sigh'
    
    p18.a.    George sighed.
        b.           s
                  (2 1)
              _______|_______
              |       |     |
             name    verb   .
              g      sigh'  |
              |       |     .
            george  sighed

[Please refer to the barred paper for the trace diagram.]

    Substatements of procedures are indented.  Because of
the sequence of procedures suspending and resuming, all
parts of a call to a procedure may not be contiguous in the
diagram.  This is indicated by the line number of the first
invocation being stated with the resumption.  For instance
on line 48 the resumption is of the call to 'rd_parse' that
first appears on line 15 and suspended on line 34.

    One successful parse generates the p_tree (p17.a).  The
interface procedure 'parse' generates this tree at lines
41-44 in the parse diagram.

    At the end (line 78), 'parse' fails indicating that no
more parses can be constructed.

    There are a few distinct things to track in this trace:
the expansion and reduction of goals through the recursion;
the reduction of 'target_length' through the recursion; and
how 'p_pos' is incremented and decremented.

    The processes of 'parse_match' are shown to go from left
to right and then to backtrack from right to left.  Looking
to the trace diagram we see that first "george" is matched
(lines 9-13), then "sighed" (lines 18-22), then "."  (lines
27-31).  The 'parse_match' that generated "." is resumed
first (line 51), then the one that generated "sighed" (line
18) and then the one that generated "george" (line 64).

    On examination of the trace diagram you will see that an
invocation of 'rd_parse' may result in two recursive calls.
The call at line 6 does the two calls at lines 7 and 15.
The call at line 15 does the two calls at lines 16 and 24.
The first of either of these pairs is an exploration of a
left branch.  At line 7 the program is exploring "name" of
["name", "verb", "."].  At line 16 it is exploring "verb" of
["verb", "."].  The second call is what is left of those
expansions after the left exploration has generated a p_tree
result.

    Another thing to notice is that where ever 'rd_parse'
results in two recursive calls the second is resumed before
the first.  This is backtracking from right to left.  This
is what causes the proper resumption of the 'parse_match'
procedures.
